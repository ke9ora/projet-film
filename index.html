<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>GPU Billboards par Texture</title>
<style>
body { margin: 0; overflow: hidden; }
</style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.5/examples/js/controls/PointerLockControls.js"></script>

<script>
(async function() {

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    
    // Positionner la caméra au centre du graphe après chargement
    // Position temporaire, sera ajustée après chargement du graphe
    camera.position.set(0, 0, 100);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.PointerLockControls(camera, document.body);
    scene.add(controls.getObject());


    document.body.addEventListener('click', () => {
        controls.lock();
    });

    const keys = {
        forward: false,
        backward: false,
        left: false,
        right: false
    };
    
    document.addEventListener('keydown', e => {
        switch (e.code) {
            case 'KeyW':
            case 'ArrowUp':
                keys.forward = true; break;
            case 'KeyS':
            case 'ArrowDown':
                keys.backward = true; break;
            case 'KeyA':
            case 'ArrowLeft':
                keys.left = true; break;
            case 'KeyD':
            case 'ArrowRight':
                keys.right = true; break;
        }
    });

    document.addEventListener('keyup', e => {
        switch (e.code) {
            case 'KeyW':
            case 'ArrowUp':
                keys.forward = false; break;
            case 'KeyS':
            case 'ArrowDown':
                keys.backward = false; break;
            case 'KeyA':
            case 'ArrowLeft':
                keys.left = false; break;
            case 'KeyD':
            case 'ArrowRight':
                keys.right = false; break;
        }
    });

    scene.add(new THREE.AmbientLight(0xffffff, 1));

    // --- Shaders
    const vertexShader = await fetch('billboard.vert').then(r => r.text());
    const fragmentShader = await fetch('billboard.frag').then(r => r.text());

    // --- Charger le graphe JSON
    const graph = await fetch('graph.json').then(r => r.json());

    // --- Calculer le centre du graphe pour positionner la caméra
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    let minZ = Infinity, maxZ = -Infinity;
    
    graph.nodes.forEach(n => {
        minX = Math.min(minX, n.x);
        maxX = Math.max(maxX, n.x);
        minY = Math.min(minY, n.y);
        maxY = Math.max(maxY, n.y);
        minZ = Math.min(minZ, n.z);
        maxZ = Math.max(maxZ, n.z);
    });
    
    const centerX = (minX + maxX) / 2;
    const centerY = (minY + maxY) / 2;
    const centerZ = (minZ + maxZ) / 2;
    const range = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
    
    // Positionner la caméra pour voir tout le graphe
    camera.position.set(centerX, centerY, centerZ + range * 1.5);
    camera.lookAt(centerX, centerY, centerZ);

    // --- Billboards avec échelle adaptée
    const billboardScale = Math.max(5, range * 0.05); // Échelle adaptée, minimum 5
    const billboards = graph.nodes.map(n => ({
        position: new THREE.Vector3(n.x, n.y, n.z),
        scale: billboardScale,
        textureName: n.texture,
        dist: 0
    }));

    const MAX_VISIBLE = 1000;
    const textureCache = new Map();
    const MAX_TEXTURES_GPU = 500;

    // --- Fonction pour récupérer une texture avec cache
    function getTexture(name) {
        if (textureCache.has(name)) return textureCache.get(name);
        const tex = new THREE.TextureLoader().load(name);
        textureCache.set(name, tex);
        if (textureCache.size > MAX_TEXTURES_GPU) {
            const firstKey = textureCache.keys().next().value;
            textureCache.get(firstKey).dispose();
            textureCache.delete(firstKey);
        }
        return tex;
    }

    // --- Grouper billboards par texture
    const billboardsByTexture = {};
    for (const b of billboards) {
        if (!billboardsByTexture[b.textureName]) billboardsByTexture[b.textureName] = [];
        billboardsByTexture[b.textureName].push(b);
    }

    // --- Créer InstancedMesh pour chaque groupe de texture
    const meshes = [];
    const quad = new THREE.PlaneBufferGeometry(1,1);

    for (const texName in billboardsByTexture) {
        const group = billboardsByTexture[texName];
        const offsets = new Float32Array(group.length * 3);
        const scales  = new Float32Array(group.length);

        for (let i=0; i<group.length; i++){
            offsets[i*3+0] = group[i].position.x;
            offsets[i*3+1] = group[i].position.y;
            offsets[i*3+2] = group[i].position.z;
            scales[i] = group[i].scale;
        }

        const instGeo = new THREE.InstancedBufferGeometry();
        instGeo.index = quad.index;
        instGeo.attributes.position = quad.attributes.position;
        instGeo.attributes.uv = quad.attributes.uv;
        instGeo.setAttribute('instanceOffset', new THREE.InstancedBufferAttribute(offsets, 3));
        instGeo.setAttribute('instanceScale', new THREE.InstancedBufferAttribute(scales, 1));

        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: { map: { value: getTexture(texName) } },
            transparent: true,
            depthTest: true,
            depthWrite: true,
            alphaTest: 0.1
        });

        const mesh = new THREE.Mesh(instGeo, material);
        mesh.count = group.length;
        scene.add(mesh);
        meshes.push({mesh, group, offsets, scales, instGeo});
    }

    // --- Culling + tri par distance
    function updateInstances() {
        const camPos = camera.position;
        const frustum = new THREE.Frustum();
        const mat = new THREE.Matrix4();
        mat.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        frustum.setFromProjectionMatrix(mat);

        for (const {mesh, group, offsets, scales, instGeo} of meshes) {
            for (let i=0; i<group.length; i++){
                const b = group[i];
                if (!frustum.containsPoint(b.position)) {
                    b.dist = Infinity;
                } else {
                    b.dist = camPos.distanceToSquared(b.position);
                }
            }

            group.sort((a,b)=>a.dist-b.dist);
            const visibleCount = Math.min(MAX_VISIBLE, group.length);

            for (let i=0; i<visibleCount; i++){
                const b = group[i];
                if (b.dist===Infinity) break;
                offsets[i*3+0] = b.position.x;
                offsets[i*3+1] = b.position.y;
                offsets[i*3+2] = b.position.z;
                scales[i] = b.scale;
            }

            instGeo.attributes.instanceOffset.needsUpdate = true;
            instGeo.attributes.instanceScale.needsUpdate = true;
            mesh.count = visibleCount;
        }
    }

    controls.addEventListener('change', updateInstances);
    updateInstances();

    // --- Arêtes
    const positions = [];
    for (const e of graph.edges){
        const a = graph.nodes.find(n=>n.id===e.from);
        const b = graph.nodes.find(n=>n.id===e.to);
        positions.push(a.x,a.y,a.z);
        positions.push(b.x,b.y,b.z);
    }
    const edgeGeo = new THREE.BufferGeometry();
    edgeGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
    const edgeMat = new THREE.LineBasicMaterial({color:0xffffff, transparent:true, opacity:0.4});
    const edges = new THREE.LineSegments(edgeGeo, edgeMat);
    scene.add(edges);


    window.addEventListener('keydown', e => {
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) {
            e.preventDefault();
        }
    });
    
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta();
        const speed = 10 * delta;
        const direction = new THREE.Vector3();

        if (controls.isLocked) {

            // vecteur direction "là où je regarde"
            camera.getWorldDirection(direction);
        
            if (keys.forward) {
                camera.position.addScaledVector(direction, speed);
            }
        
            if (keys.backward) {
                camera.position.addScaledVector(direction, -speed);
            }
        
            // strafe gauche / droite (perpendiculaire au regard)
            const right = new THREE.Vector3();
            right.crossVectors(direction, camera.up).normalize();
        
            if (keys.left) {
                camera.position.addScaledVector(right, -speed);
            }
        
            if (keys.right) {
                camera.position.addScaledVector(right, speed);
            }



            if (keys.forward)  controls.moveForward(speed);
            if (keys.backward) controls.moveForward(-speed);
            if (keys.left)     controls.moveRight(-speed);
            if (keys.right)    controls.moveRight(speed);
            if (keys.up)   camera.position.y += speed;
            if (keys.down) camera.position.y -= speed;
        }
    
        updateInstances();   // culling + tri distance
        renderer.render(scene, camera);
    }
    
    animate();


})();
</script>
</body>
</html>
